<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Robot UI ‚Äì buttons & voice</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    body { font-family: Arial; text-align: center; margin: 0; padding: 25px; }
    input { padding: 6px 10px; font-size: 16px; width: 180px; }
    button {
      width: 120px; height: 50px; margin: 8px;
      font-size: 17px; border: none; border-radius: 8px;
      background: #4caf50; color: #fff;
    }
    button:hover { background: #45a049; }
    #voiceBtns button {
      width: 140px; height: 40px; background: #2196f3;
    }
    #voiceBtns button:hover { background: #1976d2; }
    #labelBox {
      font-family: monospace; text-align: left;
      width: 260px; margin: 14px auto;
      border: 1px solid #ccc; padding: 8px; border-radius: 6px;
    }
  </style>

  <!-- TensorFlow.js and Speech Commands (match your TM export) -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/speech-commands@0.5"></script>
</head>
<body>
  <h2>Robot Control</h2>

  <!-- ESP32 IP input -->
  <p>
    ESP32 IP:
    <input id="ip" placeholder="192.168.x.x">
    <button onclick="setBase()">Set</button>
  </p>

  <!-- Manual control buttons -->
  <button onclick="send('go')">Forward</button><br>
  <button onclick="send('left')">Left</button>
  <button onclick="send('right')">Right</button><br>
  <button onclick="send('down')">Back</button>

  <!-- Status display -->
  <p id="stat">Last: ‚Äî</p>

  <!-- Voice control -->
  <div id="voiceBtns">
    <button onclick="startListening()">üé§ Start Voice</button>
    <button onclick="stopListening()">‚èπ Stop Voice</button>
  </div>
  <div id="labelBox" hidden></div>

  <script>
    /* ========== Network Helpers ========== */
    let base = "";
    function setBase() {
      const ip = document.getElementById("ip").value.trim();
      base = ip ? `http://${ip}` : "";
      document.getElementById("stat").innerText = base
        ? `Target set to ${base}`
        : "Invalid IP";
    }

    async function send(cmd) {
      if (!base) {
        alert("Set IP first");
        return;
      }
      console.log("Sending command:", cmd);

      // Map simple cmd to the ESP32 tokens you handle
      const mapped = {
        go:   "Dhruv_go",
        down: "Dhruv_down",
        left: "Dhruv_left",
        right:"Dhruv_right"
      };
      const fullCmd = mapped[cmd.toLowerCase()];
      if (!fullCmd) {
        alert("Unknown command: " + cmd);
        return;
      }

      try {
        await fetch(`${base}/command?cmd=${encodeURIComponent(fullCmd)}`);
        document.getElementById("stat").innerText = `Last: ${fullCmd}`;
      } catch (e) {
        alert(`Fetch failed (is ESP32 up?): ${e.message}`);
      }
    }

    /* ========== Voice Recognizer ========== */
    // Adjust to wherever you're serving your model:
    const MODEL_URL = "http://127.0.0.1:3002/model/";
    let CLASSES = [];                    // will be filled from metadata
    const CONF = 0.75;
    const ALLOWED_PREFIX = "Dhruv_";     // ignore labels not starting with this

    let recognizer, last = "", box = document.getElementById("labelBox");

    async function loadModel() {
      recognizer = speechCommands.create(
        "BROWSER_FFT", undefined,
        MODEL_URL + "model.json", MODEL_URL + "metadata.json"
      );
      await recognizer.ensureModelLoaded();

      // Use labels from the model to match scores[] order exactly
      CLASSES = recognizer.wordLabels();
      console.log("Loaded model labels:", CLASSES);
      box.hidden = false;
    }

    function bestLabel(scores) {
      let iMax = 0, best = scores[0] ?? 0;
      for (let i = 1; i < scores.length; i++) {
        const v = scores[i] ?? 0;
        if (v > best) { best = v; iMax = i; }
      }
      return { index: iMax, label: CLASSES[iMax], conf: best };
    }

    const labelToCmd = {
      "Dhruv_go":   "go",
      "Dhruv_down": "down",
      "Dhruv_left": "left",
      "Dhruv_right":"right"
      // NOTE: No Other_* mappings on purpose
    };

    async function startListening() {
      if (!recognizer) await loadModel();

      recognizer.listen(result => {
        const scores = result.scores || [];

        // Debug: show all class probabilities (helps tuning)
        box.innerHTML = CLASSES.map((c, i) =>
          `${c}: ${(scores[i] ?? 0).toFixed(2)}`
        ).join("<br>");

        const { label, conf } = bestLabel(scores);

        // Only act if: high conf, allowed prefix, not same as last fired
        if (conf > CONF && label && label.startsWith(ALLOWED_PREFIX) && label !== last) {
          last = label;
          console.log("Recognized (allowed):", label, conf.toFixed(2));
          const cmd = labelToCmd[label];
          if (cmd) send(cmd);
        }
      }, {
        includeSpectrogram:   true,
        probabilityThreshold: CONF,
        overlapFactor:        0.5
      });

      document.getElementById("stat").innerText = "üé§ Listening‚Ä¶";
    }

    function stopListening() {
      recognizer?.stopListening();
      document.getElementById("stat").innerText = "Voice stopped.";
      last = ""; // reset for next start
    }
  </script>
</body>
</html>
